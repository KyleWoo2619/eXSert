/*
Written by Brandon Wahl

Uses the health interfaces to increase or decreae hp amount and sets the healthbar accordingly

*/

using System;
using System.Collections;
using UnityEngine;
using UnityEngine.Serialization;
#if UNITY_EDITOR
using UnityEditor;
#endif

[DisallowMultipleComponent]
public class PlayerHealthBarManager : MonoBehaviour, IHealthSystem, IDataPersistenceManager
{
    [Serializable]
    public readonly struct HealthSnapshot
    {
        public readonly float current;
        public readonly float max;

        public float Normalized => max <= 0f ? 0f : current / max;

        public HealthSnapshot(float current, float max)
        {
            this.current = Mathf.Max(0f, current);
            this.max = Mathf.Max(0f, max);
        }
    }

    public static event Action<float> OnPlayerDamaged;
    public static event Action<float> OnPlayerHealed;
    public static event Action<HealthSnapshot> OnPlayerHealthChanged;
    public static event Action OnPlayerDied;
    public static event Action<PlayerHealthBarManager> OnPlayerHealthRegistered;

    [Header("Health Settings")]
    [SerializeField, Min(1f)] private float maxHealth = 500f;
    [SerializeField] private float currentHealth = -1f;
    [SerializeField, Range(0f, 1f)] private float startingHealthPercent = 1f;
    [SerializeField, Tooltip("When true, all incoming damage is ignored.")] private bool invulnerable = false;

    [Header("Death Handling")]
    [SerializeField, Tooltip("Automatically restart from the active checkpoint when the player dies.")]
    private bool restartFromCheckpointOnDeath = true;
    [SerializeField, Tooltip("Destroy the player GameObject after death once cleanup logic runs.")]
    private bool destroyPlayerOnDeath = false;
    [FormerlySerializedAs("deathPoseHoldSeconds")]
    [SerializeField, Range(0f, 6f), Tooltip("Seconds to wait after triggering the death animation before the loading fade may begin.")]
    private float deathFadeDelaySeconds = 3.5f;
    [SerializeField, Range(0.5f, 1f), Tooltip("Normalized time within the death animation that must be reached before triggering the loading fade.")]
    private float deathFadeNormalizedThreshold = 0.95f;

    [Header("Reactions")]
    [SerializeField, Range(0f, 1f)] private float flinchChance = 0.2f;
    [SerializeField, Range(0f, 2f)] private float flinchLockSeconds = 0.35f;

    [Header("References")]
    [SerializeField] private PlayerAnimationController animationController;
    [SerializeField] private PlayerMovement playerMovement;
    [SerializeField] private PlayerAttackManager attackManager;

    [Header("UI")]
    [SerializeField] private HealthBar healthBar;

    [Header("Debug")]
    [SerializeField, Tooltip("Damage applied when using the debug buttons.")]
    private float debugDamageAmount = 100f;

    public static PlayerHealthBarManager Instance { get; private set; }

    float IHealthSystem.currentHP => CurrentHealth;
    float IHealthSystem.maxHP => MaxHealth;

    public float CurrentHealth => currentHealth;
    public float MaxHealth => maxHealth;
    public float NormalizedHealth => maxHealth <= 0f ? 0f : currentHealth / maxHealth;
    public bool IsDead => isDead;

    private bool isDead;
    private Coroutine flinchRoutine;
    private Coroutine deathSequenceRoutine;
    private bool deathInputLockOwned;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Debug.LogWarning($"Duplicate {nameof(PlayerHealthBarManager)} detected on {name}. Destroying duplicate component.");
            Destroy(this);
            return;
        }

        Instance = this;

        if (animationController == null)
            animationController = GetComponentInChildren<PlayerAnimationController>();
        if (playerMovement == null)
            playerMovement = GetComponent<PlayerMovement>();
        if (attackManager == null)
            attackManager = GetComponent<PlayerAttackManager>();

        if (currentHealth < 0f)
        {
            currentHealth = Mathf.Clamp(maxHealth * Mathf.Clamp01(startingHealthPercent), 0f, maxHealth);
        }

        NotifyHealthChanged();
        OnPlayerHealthRegistered?.Invoke(this);
    }

    private void OnDestroy()
    {
        if (Instance == this)
        {
            Instance = null;
            OnPlayerHealthRegistered?.Invoke(null);
        }
    }

    public void HealHP(float hp)
    {
        if (isDead || hp <= 0f)
            return;

        float previous = currentHealth;
        currentHealth = Mathf.Min(maxHealth, currentHealth + hp);
        float actual = currentHealth - previous;
        if (actual <= 0f)
            return;

        OnPlayerHealed?.Invoke(actual);
        NotifyHealthChanged();
    }

    public void LoseHP(float damage)
    {
        if (isDead || invulnerable || damage <= 0f)
            return;

        float previous = currentHealth;
        currentHealth = Mathf.Max(0f, currentHealth - damage);
        float actual = previous - currentHealth;
        if (actual <= 0f)
            return;

        OnPlayerDamaged?.Invoke(actual);
        NotifyHealthChanged();

        if (currentHealth > 0f)
        {
            TryTriggerFlinch();
        }

        if (currentHealth <= 0f)
        {
            HandleDeath();
        }
    }

    public void ForceFullHeal(bool notifyListeners = true)
    {
        ResetDeathSequenceState();
        isDead = false;
        currentHealth = maxHealth;
        if (notifyListeners)
        {
            NotifyHealthChanged();
        }
    }

    public void Revive(float percentOfMax = 1f)
    {
        ResetDeathSequenceState();
        isDead = false;
        currentHealth = Mathf.Clamp(maxHealth * Mathf.Clamp01(percentOfMax), 0f, maxHealth);
        NotifyHealthChanged();
    }

    public void SetMaxHealth(float newMaxHealth)
    {
        maxHealth = Mathf.Max(1f, newMaxHealth);
        currentHealth = Mathf.Clamp(currentHealth, 0f, maxHealth);
        NotifyHealthChanged();
    }
    
    public void SetCurrentHealth(float newCurrentHealth)
    {
        currentHealth = Mathf.Clamp(newCurrentHealth, 0f, maxHealth);
        NotifyHealthChanged();

        if (currentHealth <= 0f)
        {
            HandleDeath();
        }
    }

    public void LoadData(GameData data)
    {
        maxHealth = data.maxHealth > 0 ? data.maxHealth : maxHealth;
        currentHealth = Mathf.Clamp(data.health, 0f, maxHealth);
        isDead = currentHealth <= 0f;
        if (!isDead)
        {
            ResetDeathSequenceState();
        }
        NotifyHealthChanged();
    }

    public void SaveData(GameData data)
    {
        data.maxHealth = maxHealth;
        data.health = currentHealth;
    }

    private void HandleDeath()
    {
        if (isDead)
            return;

        isDead = true;
        currentHealth = 0f;

        CancelFlinchRoutine();
        attackManager?.ForceCancelCurrentAttack();

        OnPlayerDied?.Invoke();

        if (deathSequenceRoutine != null)
        {
            StopCoroutine(deathSequenceRoutine);
        }

        deathSequenceRoutine = StartCoroutine(DeathSequenceRoutine());
    }

    private void NotifyHealthChanged()
    {
        var snapshot = new HealthSnapshot(currentHealth, maxHealth);
        if (healthBar != null)
        {
            healthBar.SetHealth(snapshot.current, snapshot.max);
        }
        OnPlayerHealthChanged?.Invoke(snapshot);
    }

    private void TryTriggerFlinch()
    {
        if (isDead)
            return;

        if (flinchChance <= 0f)
            return;

        if (flinchRoutine != null)
            return;

        if (UnityEngine.Random.value > flinchChance)
            return;

        if (animationController == null && playerMovement == null && attackManager == null)
            return;

        flinchRoutine = StartCoroutine(FlinchRoutine());
    }

    private IEnumerator FlinchRoutine()
    {
        attackManager?.ForceCancelCurrentAttack(resetCombo: false);
        playerMovement?.ApplyExternalStun(flinchLockSeconds);
        animationController?.PlayHit();

        float timer = Mathf.Max(0.05f, flinchLockSeconds);
        while (timer > 0f)
        {
            timer -= Time.deltaTime;
            yield return null;
        }

        flinchRoutine = null;
    }

    private void CancelFlinchRoutine()
    {
        if (flinchRoutine == null)
            return;

        StopCoroutine(flinchRoutine);
        flinchRoutine = null;
    }

    private IEnumerator DeathSequenceRoutine()
    {
        playerMovement?.EnterDeathState();
        AcquireDeathInputLock();
        animationController?.PlayDeath();

        yield return WaitForDeathFadeTiming();

        if (restartFromCheckpointOnDeath && SceneLoader.Instance != null)
        {
            SceneLoader.Instance.RestartFromCheckpoint();
        }

        if (destroyPlayerOnDeath)
        {
            Destroy(gameObject);
        }

        ReleaseDeathSequenceLocks();
        deathSequenceRoutine = null;
    }

    private void AcquireDeathInputLock()
    {
        if (InputReader.inputBusy)
        {
            deathInputLockOwned = false;
            return;
        }

        InputReader.inputBusy = true;
        deathInputLockOwned = true;
    }

    private void ReleaseDeathSequenceLocks()
    {
        if (deathInputLockOwned)
        {
            if (InputReader.inputBusy)
                InputReader.inputBusy = false;
            deathInputLockOwned = false;
        }
    }

    private void ResetDeathSequenceState()
    {
        if (deathSequenceRoutine != null)
        {
            StopCoroutine(deathSequenceRoutine);
            deathSequenceRoutine = null;
        }

        ReleaseDeathSequenceLocks();
        playerMovement?.ExitDeathState();
    }

    private IEnumerator WaitForDeathFadeTiming()
    {
        float delay = Mathf.Max(0f, deathFadeDelaySeconds);
        if (delay > 0f)
        {
            yield return new WaitForSecondsRealtime(delay);
        }

        if (animationController == null)
            yield break;

        float threshold = Mathf.Clamp01(deathFadeNormalizedThreshold);
        if (threshold <= 0f)
            yield break;

        float timeout = 2f;
        float elapsed = 0f;
        while (animationController.IsPlayingDeath(out float normalized))
        {
            if (normalized >= threshold)
                break;

            elapsed += Time.unscaledDeltaTime;
            if (elapsed >= timeout)
                break;

            yield return null;
        }
    }

    private void OnTriggerEnter(Collider other)
    {
        if (!other.CompareTag("Enemy"))
            return;

        if (!other.TryGetComponent(out HitboxDamageManager hitbox))
            return;

        LoseHP(hitbox.damageAmount);
    }

    public void SetInvulnerable(bool value) => invulnerable = value;

#if UNITY_EDITOR
    [ContextMenu("Debug/Apply Damage")]
    private void ContextApplyDebugDamage()
    {
        DebugApplyDamage();
    }

    [ContextMenu("Debug/Kill Player")]
    private void ContextKillPlayer()
    {
        DebugKillPlayer();
    }

    public void DebugApplyDamage()
    {
        if (!Application.isPlaying)
            return;

        float amount = Mathf.Max(1f, debugDamageAmount);
        LoseHP(amount);
    }

    public void DebugKillPlayer()
    {
        if (!Application.isPlaying)
            return;

        LoseHP(maxHealth * 2f);
    }
#endif
}

#if UNITY_EDITOR
[CustomEditor(typeof(PlayerHealthBarManager))]
public sealed class PlayerHealthBarManagerEditor : Editor
{
    public override void OnInspectorGUI()
    {
        base.OnInspectorGUI();

        using (new EditorGUI.DisabledScope(!Application.isPlaying))
        {
            var manager = (PlayerHealthBarManager)target;
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Debug Tools", EditorStyles.boldLabel);
            if (GUILayout.Button("Apply Debug Damage"))
            {
                manager.DebugApplyDamage();
            }
            if (GUILayout.Button("Kill Player"))
            {
                manager.DebugKillPlayer();
            }
        }
    }
}
#endif
